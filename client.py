# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'client.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
import sys
import struct
import socket
import time
from ftplib import FTP
from PyQt5.Qt import *
from PyQt5 import QtCore, QtGui, QtWidgets

  # a local server
TCP_PORT = 1456  # Just a random choice
BUFFER_SIZE = 1024  # Standard chioce
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

class Ui_Client(object):

    def __init__(self):
        self.slm = QStringListModel()  # listView的模型
        self.ftp = FTP()  # 实例化FTP
        self.select_file = ""  # listView中选择的文件名
        self.file_list = []  # 存放查询FTP返回的当前目录所有文件列表
        self.model = QDirModel()

    def setupUi(self, Client):
        Client.setObjectName("Client")
        Client.resize(561, 435)
        self.gridLayout = QtWidgets.QGridLayout(Client)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.label_2 = QtWidgets.QLabel(Client)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_8.addWidget(self.label_2)
        self.lineEdit_2 = QtWidgets.QLineEdit(Client)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.horizontalLayout_8.addWidget(self.lineEdit_2)
        self.gridLayout.addLayout(self.horizontalLayout_8, 0, 0, 1, 2)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_3 = QtWidgets.QPushButton(Client)
        self.pushButton_3.setObjectName("pushButton_3")
        self.horizontalLayout.addWidget(self.pushButton_3)
        self.pushButton_7 = QtWidgets.QPushButton(Client)
        self.pushButton_7.setObjectName("pushButton_7")
        self.horizontalLayout.addWidget(self.pushButton_7)
        self.pushButton = QtWidgets.QPushButton(Client)
        self.pushButton.setObjectName("pushButton")
        self.horizontalLayout.addWidget(self.pushButton)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.label = QtWidgets.QLabel(Client)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.label_6 = QtWidgets.QLabel(Client)
        self.label_6.setObjectName("label_6")
        self.horizontalLayout_4.addWidget(self.label_6)
        self.lineEdit_4 = QtWidgets.QLineEdit(Client)
        self.lineEdit_4.setObjectName("lineEdit_4")
        self.horizontalLayout_4.addWidget(self.lineEdit_4)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        self.treeView = QtWidgets.QTreeView(Client)
        self.treeView.setObjectName("treeView")
        self.verticalLayout.addWidget(self.treeView)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.pushButton_2 = QtWidgets.QPushButton(Client)
        self.pushButton_2.setObjectName("pushButton_2")
        self.horizontalLayout_2.addWidget(self.pushButton_2)
        self.pushButton_5 = QtWidgets.QPushButton(Client)
        self.pushButton_5.setObjectName("pushButton_5")
        self.horizontalLayout_2.addWidget(self.pushButton_5)
        self.pushButton_4 = QtWidgets.QPushButton(Client)
        self.pushButton_4.setObjectName("pushButton_4")
        self.horizontalLayout_2.addWidget(self.pushButton_4)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.label_4 = QtWidgets.QLabel(Client)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_2.addWidget(self.label_4)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.label_7 = QtWidgets.QLabel(Client)
        self.label_7.setObjectName("label_7")
        self.horizontalLayout_6.addWidget(self.label_7)
        self.lineEdit_6 = QtWidgets.QLineEdit(Client)
        self.lineEdit_6.setObjectName("lineEdit_6")
        self.horizontalLayout_6.addWidget(self.lineEdit_6)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.listView = QtWidgets.QListView(Client)
        self.listView.setObjectName("listView")
        self.verticalLayout_2.addWidget(self.listView)
        self.gridLayout.addLayout(self.verticalLayout_2, 1, 1, 1, 1)
        self.label_3 = QtWidgets.QLabel(Client)
        self.label_3.setObjectName("label_3")
        self.gridLayout.addWidget(self.label_3, 2, 0, 1, 1)
        self.textBrowser = QtWidgets.QTextEdit(Client)
        self.textBrowser.setMaximumSize(QtCore.QSize(16777215, 135))
        self.textBrowser.setObjectName("textEdit")
        self.gridLayout.addWidget(self.textBrowser, 3, 0, 1, 2)

        self.retranslateUi(Client)
        QtCore.QMetaObject.connectSlotsByName(Client)

    def retranslateUi(self, Client):
        _translate = QtCore.QCoreApplication.translate
        Client.setWindowTitle(_translate("Client", "Client"))
        self.label.setText(_translate("Client", "客户端"))
        self.label_6.setText(_translate("Client", "Selected file："))
        self.label_2.setText(_translate("Client", "服务器ip"))
        self.label_4.setText(_translate("Client", "服务器"))
        self.label_7.setText(_translate("Client", "Selected file："))
        self.label_3.setText(_translate("Client", "提示"))

        self.pushButton_3.setText(_translate("Client", "连接"))
        self.pushButton_7.setText(_translate("Client", "显示"))
        self.pushButton.setText(_translate("Client", "上传"))
        self.pushButton_2.setText(_translate("Client", "下载"))
        self.pushButton_5.setText(_translate("Client", "删除"))
        self.pushButton_4.setText(_translate("Client", "断开"))

        self.treeView.setModel(self.model)
        self.treeView.doubleClicked.connect(self.select_item)
        self.treeView.show()

        self.listView.setModel(self.slm)
        self.listView.doubleClicked.connect(self.select_index)
        self.listView.show()

        self.pushButton_3.clicked.connect(self.conn)
        self.pushButton.clicked.connect(self.upld)
        self.pushButton_4.clicked.connect(self.quit)
        self.pushButton_2.clicked.connect(self.dwld)
        self.pushButton_5.clicked.connect(self.delf)
        self.pushButton_7.clicked.connect(self.display)

    def select_item(self, QModelIndex):
        localPath = self.model.filePath(QModelIndex)
        self.lineEdit_4.setText(str(localPath))

    def select_index(self, qModelIndex):
        self.lineEdit_6.setText(str(self.file_list[qModelIndex.row()]))

    def conn(self):
        # Connect to the server
        global s
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        TCP_IP = self.lineEdit_2.text()
        self.textBrowser.setText("Sending server request...")
        try:
            s.connect((TCP_IP, TCP_PORT))
            self.textBrowser.setText("Connection sucessful")
        except Exception as e:
            self.textBrowser.setText("Connection unsucessful. Make sure the server is online, and the ip is correct.")

    def display(self):
        try:
            # Send list request
            s.send(bytes("LIST", encoding="utf-8"))
        except Exception as e:
            self.textBrowser.setText("Couldn't make server request. Make sure a connection has been established.")
            return
        try:
            # First get the number of files in the directory
            self.file_list = []
            number_of_files = struct.unpack("i", s.recv(4))[0]
            # Then enter into a loop to recieve details of each, one by one
            for i in range(int(number_of_files)):
                # Get the file name size first to slightly lessen amount transferred over socket
                file_name_size = struct.unpack("i", s.recv(4))[0]
                file_name = s.recv(file_name_size)
                s.send(bytes('1', encoding="utf-8"))
                # Also get the file size for each item in the server
                file_size = struct.unpack("i", s.recv(4))[0]
                # Make sure that the client and server are syncronised
                s.send(bytes("1", encoding="utf-8"))
                self.file_list.append(file_name.decode(encoding='utf-8'))
            # Get total size of directory
            self.slm.setStringList(self.file_list)
            total_directory_size = struct.unpack("i", s.recv(4))[0]
            self.textBrowser.setText(str("Total directory size: {}b".format(total_directory_size)))
        except Exception as e:
            self.textBrowser.setText("Couldn't retrieve listing")
            return
        try:
            # Final check
            s.send(bytes("1", encoding="utf-8"))  # 二次确认
            return
        except:
            self.textBrowser.setText("Couldn't get final server confirmation")
            return

    def upld(self):
        file_path = self.lineEdit_4.text()
        file_name = os.path.basename(file_path)
        self.textBrowser.setText("\nUploading file: {}...".format(file_path))
        try:
            # Check the file exists
            content = open(str(file_path), "rb")
        except:
            self.textBrowser.setText("Couldn't open file. Make sure the file name was entered correctly.")
            return
        try:
            # Make upload request
            s.send(bytes("UPLD", encoding="utf-8"))
        except:
            self.textBrowser.setText("Couldn't make server request. Make sure a connection has bene established.")
            return
        try:
            # Wait for server acknowledgement then send file details
            # Wait for server ok
            s.recv(BUFFER_SIZE)
            # Send file name size and file name
            s.send(struct.pack("h", sys.getsizeof(file_name)))
            s.send(bytes(file_name, encoding="utf-8"))
            # Wait for server ok then send file size
            s.recv(BUFFER_SIZE)
            s.send(struct.pack("i", os.path.getsize(file_path)))
        except Exception as e:
            self.textBrowser.setText(e)
            self.textBrowser.setText("Error sending file details")
        mark_file1 = s.recv(BUFFER_SIZE)
        if (mark_file1 == b'1'):
            try:
                remain_size = struct.unpack("i", s.recv(4))[0]
                l = content.read(remain_size)
                self.textBrowser.setText("\nSending-reupld...")
                l = content.read(BUFFER_SIZE)
                self.textBrowser.setText("\nReuploading...")
                send_size = remain_size
                while l:
                    s.send(l)
                    l = content.read(BUFFER_SIZE)
                    send_size += BUFFER_SIZE
                    s.recv(BUFFER_SIZE)
                    s.send(bytes('1', encoding="utf-8"))
                    self.textBrowser.setText('Have Transferred:{} B'.format(send_size))
                content.close()
                # Get upload performance details
                upload_time = struct.unpack("f", s.recv(4))[0]
                upload_size = struct.unpack("i", s.recv(4))[0]
                self.textBrowser.setText("\nSent file: {}\nTime elapsed: {}s\nFile size: {}b".format(file_name, upload_time, upload_size))
            except Exception as e:
                self.textBrowser.setText(e)
                self.textBrowser.setText("Error sending file")
                return
        elif (mark_file1 == b'2'):
            self.textBrowser.setText("This file has already been uploaded\n")
            return
        else:
            try:
                # Send the file in chunks defined by BUFFER_SIZE
                # Doing it this way allows for unlimited potential file sizes to be sent
                l = content.read(BUFFER_SIZE)
                self.textBrowser.setText("\nSending...")
                send_size = 0
                while l:
                    s.send(l)
                    l = content.read(BUFFER_SIZE)
                    send_size += BUFFER_SIZE
                    s.recv(BUFFER_SIZE)
                    s.send(bytes('1', encoding="utf-8"))
                    self.textBrowser.setText('Have Transferred:{} B'.format(send_size))
                content.close()
                # Get upload performance details
                upload_time = struct.unpack("f", s.recv(4))[0]
                upload_size = struct.unpack("i", s.recv(4))[0]
                self.textBrowser.setText("\nSent file: {}\nTime elapsed: {}s\nFile size: {}b".format(file_name, upload_time, upload_size))
            except Exception as e:
                self.textBrowser.setText(e)
                self.textBrowser.setText("Error sending file")
                return
        return


    def dwld(self):
        file_name = self.lineEdit_6.text()
        self.textBrowser.setText("Downloading file: {}".format(file_name))
        try:
            # Send server request
            s.send(bytes("DWLD", encoding="utf-8"))
        except:
            self.textBrowser.setText("Couldn't make server request. Make sure a connection has bene established.")
            return
        try:
            # Wait for server ok, then make sure file exists
            s.recv(BUFFER_SIZE)
            # Send file name length, then name
            s.send(struct.pack("h", sys.getsizeof(file_name)))
            s.send(bytes(file_name, encoding="utf-8"))
            # Get file size (if exists)
            file_size = struct.unpack("i", s.recv(4))[0]
            if file_size == -1:
                # If file size is -1, the file does not exist
                self.textBrowser.setText("File does not exist. Make sure the name was entered correctly")
                return
        except:
            self.textBrowser.setText("Error checking file")
        try:
            if (os.path.exists(file_name)):
                if (os.path.getsize(file_name) != file_size):
                    self.textBrowser.setText("This file must be redownloaded\n")
                    # Send ok to recieve file content
                    s.send(bytes("1", encoding='utf-8'))
                    s.send(struct.pack("i", os.path.getsize(file_name)))
                    # Enter loop to recieve file
                    output_file = open(file_name, "ab")
                    bytes_recieved = os.path.getsize(file_name)
                    self.textBrowser.setText("\nDownloading...")
                    t1 = time.time()
                    while bytes_recieved < file_size:
                        # Again, file broken into chunks defined by the BUFFER_SIZE variable
                        l = s.recv(BUFFER_SIZE)
                        s.send(bytes('1', encoding='utf-8'))
                        output_file.write(l)
                        bytes_recieved += BUFFER_SIZE
                        self.textBrowser.setText('Recieved: {} KB  [{}/{}]'.format(bytes_recieved >> 10, bytes_recieved >> 10,
                                                                file_size >> 10))
                    output_file.close()
                    self.textBrowser.setText("Successfully downloaded {}".format(file_name))
                    # Tell the server that the client is ready to recieve the download performance details
                    s.send(bytes("1", encoding='utf-8'))
                    # Get performance details
                    # time_elapsed = struct.unpack("f", s.recv(4))[0]
                    self.textBrowser.setText("Time elapsed: {}s\nFile size: {}b".format(time.time() - t1, file_size))
                else:
                    s.send(bytes("2", encoding='utf-8'))
                    self.textBrowser.setText("This file has been downloaded")
                    return
            else:
                # Send ok to recieve file content
                s.send(bytes("0", encoding='utf-8'))
                # Enter loop to recieve file
                output_file = open(file_name, "wb")
                bytes_recieved = 0
                self.textBrowser.setText("\nDownloading...")
                t1 = time.time()
                while bytes_recieved < file_size:
                    # Again, file broken into chunks defined by the BUFFER_SIZE variable
                    l = s.recv(BUFFER_SIZE)
                    output_file.write(l)
                    bytes_recieved += BUFFER_SIZE
                    self.textBrowser.setText(
                        'Recieved: {} KB  [{}/{}]'.format(bytes_recieved >> 10, bytes_recieved >> 10, file_size >> 10))
                output_file.close()
                self.textBrowser.setText("Successfully downloaded {}".format(file_name))
                # Tell the server that the client is ready to recieve the download performance details
                s.send(bytes("1", encoding='utf-8'))
                # Get performance details
                # time_elapsed = struct.unpack("f", s.recv(4))[0]
                self.textBrowser.setText("Time elapsed: {}s\nFile size: {}b".format(time.time() - t1, file_size))
        except:
            self.textBrowser.setText("Error downloading file")
            return
        return

    def delf(self):
        file_name = self.lineEdit_6.text()
        self.textBrowser.setText("Deleting file: {}...".format(file_name))
        try:
            # Send resquest, then wait for go-ahead
            s.send(bytes("DELF", encoding="utf-8"))
            s.recv(BUFFER_SIZE)
        except:
            self.textBrowser.setText("Couldn't connect to server. Make sure a connection has been established.")
            return
        try:
            # Send file name length, then file name
            s.send(struct.pack("h", sys.getsizeof(file_name)))
            s.send(bytes(file_name, encoding='utf-8'))
        except:
            self.textBrowser.setText("Couldn't send file details")
            return
        try:
            # Get conformation that file does/doesn't exist
            file_exists = struct.unpack("i", s.recv(4))[0]
            if file_exists == -1:
                self.textBrowser.setText("The file does not exist on server")
                return
        except:
            self.textBrowser.setText("Couldn't determine file existance")
            return
        confirm_delete = "Y"
        try:
            # Send conformation
            if confirm_delete == "Y" or confirm_delete == "YES":
                # User wants to delete file
                s.send(bytes("Y", encoding="utf-8"))
                # Wait for conformation file has been deleted
                delete_status = struct.unpack("i", s.recv(4))[0]
                if delete_status == 1:
                    self.textBrowser.setText("File successfully deleted")
                    return
                else:
                    # Client will probably send -1 to get here, but an else is used as more of a catch-all
                    self.textBrowser.setText("File failed to delete")
                    return
            else:
                s.send(bytes("N", encoding="utf-8"))
                self.textBrowser.setText("Delete abandoned by user!")
                return
        except:
            self.textBrowser.setText("Couldn't delete file")
            return


    def quit(self):
        s.send(bytes("QUIT", encoding='utf-8'))
        # Wait for server go-ahead
        s.recv(BUFFER_SIZE)
        s.close()
        self.textBrowser.setText("Server connection ended")
        return



if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    widget = QtWidgets.QWidget()
    ui = Ui_Client()
    ui.setupUi(widget)
    widget.show()
    sys.exit(app.exec_())